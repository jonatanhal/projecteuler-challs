/*

The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7
= 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five
divisors.

What is the value of the first triangle number to have over five
hundred divisors?

*/

package main

import (
	"fmt"
	"math"
)

func triangleNumber(index uint64) (sum uint64) {
	for i := uint64(1); i <= index; i++ { sum += i }
	return
}

func sieve(max uint64) (p []uint64) {
	m := uint64(math.Sqrt(float64(max)))
	n := uint64(float64(max)/math.Log(float64(max))) + m<<11
	f := make([]bool,n)

	for i := range f {
		f[i]=true
	}

	for i := uint64(2); i <= m; i++ {
		if f[i] {
			x := uint64(1)
			for j := i+i; j < max; j = i*2+i*x {
				x++
				f[j] = false
			}
		}
	}

	for i := range f {
		if f[i] {
			p = append(p, uint64(i))
		}
	}
	return
}

func factor(n uint64, p []uint64) (factors []int) {
	b := n
	fmt.Printf("Factorizing %d\n",n)
	for i := uint64(2) ; i < b/2 ; {
		if n % i == 0 {
			factors = append(factors, int(i))
			n /= i
		} else {
			i++ 
		}
	}

	fmt.Println("second iteration, to break up larger factors")
	nn := []int{}
	for i := range factors {
		f := factors[i]
		bb := f
		if f > 7 {
			for j := 2; j < bb / 2 ; {
				if f % j == 0 {
					nn = append(nn,j)
					f /= j
				} else {
					j++
				}
			}
		} else {
			nn = append(nn,f)
		}
	}

	sum := uint64(0) 
	for _, f := range nn {
		if sum == uint64(0) {
			sum = uint64(f)
		} else {
			sum *= uint64(f)
		}
	}

	if sum != b {
		fmt.Printf("incomplete/broken factorization!\n")
		return []int{}
	}
	return
}

func main() {
	n := uint64(100)
	factors := factor(triangleNumber(n),sieve(n))
	for _,f := range factors {
		fmt.Printf("%d ",f)
	}
	fmt.Println("")
}
